---
title: "Predicting the age of abalone by using only physical measurements"
subtitle: "Group 005E06"
author: "Reid Wang, Ivan Yeh, Christy Lee, Paihao Zhang and Honghui Huang"
format: 
  revealjs:
    auto-slide: 20000
    embed-resources: true
    width: 1600
    height: 900
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Introduction to the Data

<!-- Slide 2 (Since there was a title slide) -->

-   Sourced from the [UCI ML Repo](https://archive.ics.uci.edu/dataset/1/abalone) (Nash et al., 1995)
-   Consists of measurements taken from 4177 abalone
-   The continuous variables were multiplied by 200 at this step.

```{css}
.reveal table {
  font-size: x-large;
}
```

| **Field Name** | **Data Type** | **Data Format** | **Length** | **Description**                  | **Example** |
|------------|------------|------------|------------|------------|------------|
| Sex            | Character     | X               | 1          | Sex of abalone                   | M, F, I     |
| Length         | Float         | N.NNN           | 4          | Length in mm $\div$ 200          | 0.455       |
| Diameter       | Float         | N.NNN           | 4          | Diameter in mm $\div$ 200        | 0.365       |
| Height         | Float         | N.NNN           | 4          | Height in mm $\div$ 200          | 0.095       |
| Whole_weight   | Float         | N.NNNN          | 5          | Whole weight in g $\div$ 200     | 0.5140      |
| Shucked_weight | Float         | N.NNNN          | 5          | Weight of meat in g $\div$ 200   | 0.2245      |
| Viscera_weight | Float         | N.NNNN          | 5          | Gut weight in g $\div$ 200       | 0.1010      |
| Shell_weight   | Float         | N.NNNN          | 4          | Dry shell weight in g $\div$ 200 | 0.150       |
| Rings          | Integer       | NN              | 2          | No. of rings, +1.5 for age       | 15          |

<!-- Slide 3 -->

## Introduction to the Problem

-   Goal is to predict the age of abalone using physical measurements
-   This speeds up the process of surveying abalone age
-   But a model that includes shucked weight, viscera weight and shell weight would still require killing the abalone

::: columns
::: {.column width="40%"}

<center>
![](pictures/abalone.png){width="60%"}
  \
<sup><sub> [Image Source](https://www.researchgate.net/figure/Size-and-age-of-Haliotis-midae-animals-used-in-this-study-8-6-mo-7-12-mo-6-18-mo_fig1_276190933) </sub></sup>
</center>

:::

::: {.column width="60%"}

<center>
![](pictures/rings.png){width="70%"}
  \
<sup><sub> [Image Source](https://www.researchgate.net/figure/Stained-section-through-a-blacklip-abalone-shell-showing-alternating-dark-and-light_fig2_242293422) </sub></sup>
</center>

:::

:::

<!-- Slide 4 -->

## Model Selection: Context of Variables

- So we decided to also make a "live" model, which uses variables that can be measured without killing the abalone
- This will be compared with the full model later

| **Original Dataset** | **Live Abalone Dataset** |
|----------------------|--------------------------|
| Sex                  | Sex                      |
| Length               | Length                   |
| Diameter             | Diameter                 |
| Height               | Height                   |
| Whole_weight         | Whole_weight             |
| Shucked_weight       | Rings                    |
| Viscera_weight       |                          |
| Shell_weight         |                          |
| Rings                |                          |

<!-- Slide 5 -->

## Data Distribution

-   There were no missing values and the data is independent.
-   Rings is positively skewed

::: columns
::: {.column width="70%"}
```{r, tidy = TRUE, warning = FALSE, message=FALSE}
library("tidyverse")
library("gt")
library("janitor")
library("grid") 
library("gridExtra") 
library("cowplot") 
library("gt")
library("caret")
library("ggfortify")

rawdata = read.csv("abalone.data", header = FALSE)
names(rawdata) = c("Sex","Length","Diameter","Height","Whole_weight","Shucked_weight","Viscera_weight","Shell_weight","Rings")

rawdata = rawdata |> mutate(
  Sex = Sex,
  Length = Length * 200,
  Diameter = Diameter * 200,
  Height = Height * 200,
  Whole_weight = Whole_weight * 200,
  Shucked_weight = Shucked_weight * 200,
  Viscera_weight = Viscera_weight * 200,
  Shell_weight = Shell_weight * 200, 
  Rings = Rings * 200
)

rawdata_live = tibble(
  Sex = rawdata$Sex,
  Length = (rawdata$Length),
  Diameter = (rawdata$Diameter),
  Height = rawdata$Height,
  Whole_weight = (rawdata$Whole_weight),
  Rings = rawdata$Rings
)

rawdata$Sex <- factor(rawdata$Sex, levels = c("M", "F", "I"))

par( mfrow= c(2,4) )
plot1 <- ggplot(rawdata, aes(y=Rings, x=Length, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot2 <- ggplot(rawdata, aes(y=Rings, x=Diameter, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot3 <- ggplot(rawdata, aes(y=Rings, x=Height, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot4 <- ggplot(rawdata, aes(y=Rings, x=Whole_weight, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot5 <- ggplot(rawdata, aes(y=Rings, x=Shucked_weight, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot6 <- ggplot(rawdata, aes(y=Rings, x=Viscera_weight, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot7 <- ggplot(rawdata, aes(y=Rings, x=Shell_weight, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
legend <- get_legend(ggplot(rawdata, aes(y=Rings, x=Length, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))) 
grid.arrange(plot1, plot2, plot3, plot4, plot5, plot6, plot7, legend, ncol=4)
```
:::

::: {.column width="30%"}
```{r, tidy = TRUE, warning = FALSE, message=FALSE}
rawdata |> 
  ggplot() + 
  aes(x = Rings) + 
  geom_histogram(binwidth = 1, colour='black',size=1, fill="grey")+ 
  labs(x = "Rings", y = "Count") + 
  theme_bw()

scaleddata = subset(rawdata, select = -c(Sex))
scaleddata = scale(scaleddata)

library("reshape")
meltData <- melt(scaleddata)
colnames(meltData) = c("ID", "Parameter", "Value")
meltData$Value <- as.numeric(meltData$Value)

# ggplot(meltData, aes(x=Parameter, y=Value, fill=Parameter)) +
#   geom_boxplot() +
#   coord_flip()

ggplot(meltData, aes(x=Parameter, y=Value, fill=Parameter)) +
  geom_boxplot() +
  coord_flip() +
  ylim(-5,5)
```
:::
:::

<!-- Slide 6 -->

## Improving Linearity

The scaling factor for each variable is as follows:

<font size="5">

$-(\frac{1}{Rings})^{\frac{1}{4}} = \beta_0 + Sex[M] + Sex [F] + Sex[I] + \beta_1\log_{10}(Length) + \beta_2\log_{10}(Diameter) + \beta_3Height^{\left(\frac{1}{3}\right)}$

$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ + \beta_4\log_{10}(Whole\ Weight) + \beta_5\log_{10}(Shucked\ Weight)$

$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ + \beta_6\log_{10}(Viscera\ Weight) + \beta_7\log_{10}(Shell\ Weight) + \varepsilon_i$

</font>

```{r, tidy = TRUE, fig.align = 'center', warning = FALSE, message=FALSE}
data_scaled = rawdata |> mutate(
  Sex = Sex,
  Length = log10(Length),
  Diameter = log10(Diameter),
  Height = Height^(1/3),
  Whole_weight = log10(Whole_weight),
  Shucked_weight = log10(Shucked_weight),
  Viscera_weight = log10(Viscera_weight),
  Shell_weight = log10(Shell_weight), 
  Rings = -(1/Rings)^0.25,
)

data_scaled_live = tibble(
  Sex = rawdata$Sex,
  Length = log10(rawdata$Length),
  Diameter = log10(rawdata$Diameter),
  Height = rawdata$Height^(1/3),
  Whole_weight = log10(rawdata$Whole_weight),
  Rings = -(1/rawdata$Rings)^0.25,
)

data_scaled$Sex <- factor(data_scaled$Sex, levels = c("M", "F", "I"))

par( mfrow= c(2,4) )
plot1 <- ggplot(data_scaled, aes(y=Rings, x=Length, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot2 <- ggplot(data_scaled, aes(y=Rings, x=Diameter, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot3 <- ggplot(data_scaled, aes(y=Rings, x=Height, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot4 <- ggplot(data_scaled, aes(y=Rings, x=Whole_weight, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot5 <- ggplot(data_scaled, aes(y=Rings, x=Shucked_weight, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot6 <- ggplot(data_scaled, aes(y=Rings, x=Viscera_weight, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
plot7 <- ggplot(data_scaled, aes(y=Rings, x=Shell_weight, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + theme(legend.position="none") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))
legend <- get_legend(ggplot(data_scaled, aes(y=Rings, x=Length, colour = Sex)) + geom_point() + geom_smooth(method = "lm", colour = "black") + scale_color_manual(values = c("#008FFF", "#FF3200", "#46D100"))) 
grid.arrange(plot1, plot2, plot3, plot4, plot5, plot6, plot7, legend, ncol=4)
```

<!-- Slide 7 -->

## Correlation heat map

All variables are highly correlated with all the coefficients of determination ≥ 0.6

```{r}
cor_mat = cor(data_scaled[,2:9])
cor_mat_melted = cor_mat |>
  data.frame() |> 
  rownames_to_column(var = "var1") |> 
  pivot_longer(cols = -var1, 
               names_to = "var2",
               values_to = "cor")

# proportion of relationships having a r squared ≥ 0.6
#mean(cor_mat_melted >= 0.6)

cor_mat_melted |> ggplot() + 
  aes(x=var1, y=var2, fill=cor) + 
  geom_tile() + 
  theme_minimal(base_size = 20) +
  scale_fill_gradient2(
    low = "blue", 
    high = "red", 
    mid = "white", 
    midpoint = 0, 
    limit = c(-1,1)) +
  theme(
    axis.text.x = element_text(
      angle = 90, hjust = 1
    )
  )
```



<!-- Slide 8 -->

## Model Selection: AIC Minimisation Approach
- Penalise unnecessary variables
- Form the best combination of variables to fit the model 
- The lower the AIC the better 

### Backward Approach 
- Start from a full model 
- Remove the least formative predictor, variable by variable, to minimise AIC 

### Forward Approach 
- Start from a null model 
- Add the most formative predictor, variable by variable, to minimise AIC 

<!-- Slide 9 -->

## Model Selection: AIC Minimisation Approach

```{r}
M0_scaled_live = lm(Rings ~ 1, data = data_scaled_live)  # Null model
M1_scaled_live = lm(Rings ~ ., data = data_scaled_live)  # Full model

M0_scaled = lm(Rings ~ 1, data = data_scaled)  # Null model
M1_scaled = lm(Rings ~ ., data = data_scaled)  # Full model


step.back.aic.scaled.live = step(M1_scaled_live, 
                     direction = "backward", 
                     trace = FALSE)
step.back.aic.scaled = step(M1_scaled, 
                     direction = "backward", 
                     trace = FALSE)

#round(summary(step.back.aic.scaled.live)$coef,3) |> knitr::kable()
#round(summary(step.back.aic.scaled)$coef,3) |> knitr::kable()

step.fwd.aic.scaled.live = step(M0_scaled_live, 
                                scope = list(lower = M0_scaled_live, upper = M1_scaled_live),
                                direction = "forward", 
                                trace = FALSE)
step.fwd.aic.scaled = step(M0_scaled, 
                           scope = list(lower = M0_scaled, upper = M1_scaled),
                           direction = "forward", 
                           trace = FALSE)

#round(summary(step.fwd.aic.scaled.live)$coef,3) |> knitr::kable()
#round(summary(step.fwd.aic.scaled)$coef,3) |> knitr::kable()
```

<font size="5"> The selection process involves forward searching and back searching based on the scaled live and full abalone datasets. </font>

```{r}
sjPlot::tab_model(step.back.aic.scaled.live, step.fwd.aic.scaled.live, step.back.aic.scaled, step.fwd.aic.scaled, show.ci = FALSE, show.aic = TRUE,
                  dv.labels = c("Backward Live Abalone Model", "Forward Live Abalone Model", "Backward Original Model", "Forward Original Model"))
```

<!-- Slide 10 -->

## Models Produced 

### Live Abalone Model
<font size="6">

$-(\frac{1}{Rings})^{\frac{1}{4}} = -0.2160858 + 0.0003333Sex[F] - 0.0029337Sex [I] -0.0437280\log_{10}(Length)$

$+ 0.0554263\log_{10}(Diameter)+ 0.0084491Height^{\left(\frac{1}{3}\right)} + 0.0104607\log_{10}(Whole\ Weight)$

</font>

  \
### Original Abalone Model
<font size="6">

$-(\frac{1}{Rings})^{\frac{1}{4}} = -0.2072139 - 0.0001040Sex[F] - 0.0018633Sex[I] -0.0222445\log_{10}(Length)$

$+ 0.0192558\log_{10}(Diameter) + 0.0031554Height^{\left(\frac{1}{3}\right)} + 0.0466486\log_{10}(Whole\ Weight)$

$-0.0484394\log_{10}(Shucked\ Weight)- 0.0058606\log_{10}(Viscera\ Weight) + 0.0309122\log_{10}(Shell\ Weight)$
</font>

<!-- Slide 11 -->

## Explaining the Live Model
<font size="6">

$-(\frac{1}{Rings})^{\frac{1}{4}} = -0.2160858 + 0.0003333Sex[F] - 0.0029337Sex [I] -0.0437280\log_{10}(Length)$

$+ 0.0554263\log_{10}(Diameter)+ 0.0084491Height^{\left(\frac{1}{3}\right)} + 0.0104607\log_{10}(Whole\ Weight)$

</font>

- Male variable becomes the intercept
- 1 for the corresponding sex, 0 for others
- We expect, leaving all else constant:
  - For every 1 unit increase in log length, the quad root of inverse Rings increases by 0.0437280
  - For every 1 unit increase in cube root in height, the quad root of inverse Rings decreases by 0.0084491
  - All variables deduced in a similar manner


<!-- Slide 12 -->

## Explaining the Original Model
<font size="6">

$-(\frac{1}{Rings})^{\frac{1}{4}} = -0.2072139 - 0.0001040Sex[F] - 0.0018633Sex[I] -0.0222445\log_{10}(Length)$

$+ 0.0192558\log_{10}(Diameter) + 0.0031554Height^{\left(\frac{1}{3}\right)} + 0.0466486\log_{10}(Whole\ Weight)$

$-0.0484394\log_{10}(Shucked\ Weight)- 0.0058606\log_{10}(Viscera\ Weight) + 0.0309122\log_{10}(Shell\ Weight)$
</font>

- Male variable becomes the intercept
- 1 for the corresponding sex, 0 for others
- We expect, leaving all else constant:
  - For every 1 unit increase in log length, the quad root of inverse Rings increases by 0.0222445
  - For every 1 unit increase in cube root in height, the quad root of inverse Rings decreases by 0.0031554
  - All variables deduced in a similar manner

<!-- Slide 13 -->

## Model Assumption Checking
Live Abalone Model (Scaled)
```{r}
autoplot(M1_scaled_live, which = 1:2)
```
<font size = 5>

-   Linearity: Residuals are approximately symmetrical in its distribution above and below zero.
-   Normality: Residuals are approximately normally distributed since most of the points align with the normal line.
-   Homoscedasticity: Residuals are scattered symmetrically around the 0 line with fairly even variance and linearity.

</font>

<!-- Slide 14 -->

## Model Assumption Checking
Original Abalone Model (Scaled)
```{r}
autoplot(M1_scaled, which = 1:2)
```
<font size = 5>

-   Linearity: Residuals are approximately symmetrical in its distribution above and below zero.
-   Normality: Residuals are approximately normally distributed since most of the points align with the normal line.
-   Homoscedasticity: Residuals are scattered symmetrically around the 0 line with fairly even variance and linearity.

</font>


<!-- Slide 15 -->

## Performance Assessment - Cross Validation

Live abalone data (scaled)
```{r, message=FALSE, warning=FALSE}
cv_scaled = train(
  Rings ~ ., 
  data = data_scaled_live,
  method = "lm",
  trControl = trainControl(
    method = "cv", number = 10,
    verboseIter = FALSE
  )
)
round(cv_scaled$results[c("Rsquared", "RMSE", "MAE")], 3) |> knitr::kable()
```

Raw live abalone data (no scaling)
```{r, message=FALSE, warning=FALSE}
cv_raw = train(
  Rings ~ ., 
  data = rawdata_live,
  method = "lm",
  trControl = trainControl(
    method = "cv", number = 10,
    verboseIter = FALSE
  )
)
round(cv_raw$results[c("Rsquared", "RMSE", "MAE")], 3) |> knitr::kable()
```

Original data (scaled)
```{r, message=FALSE, warning=FALSE}
cv_live_scaled = train(
  Rings ~ ., 
  data = data_scaled,
  method = "lm",
  trControl = trainControl(
    method = "cv", number = 10,
    verboseIter = FALSE
  )
)
round(cv_live_scaled$results[c("Rsquared", "RMSE", "MAE")], 3) |> knitr::kable()
```

Raw Original data (no scaling)
```{r, message=FALSE, warning=FALSE}
cv_raw = train(
  Rings ~ ., 
  data = rawdata,
  method = "lm",
  trControl = trainControl(
    method = "cv", number = 10,
    verboseIter = FALSE
  )
)
round(cv_raw$results[c("Rsquared", "RMSE", "MAE")], 3) |> knitr::kable()
```

<!-- Slide 16 -->

## Implications of the Original Model

- Performs slightly better, but is environmentally damaging
- More suitable if abalone are already intended for harvest, but can’t be used for some research applications (e.g. endangered species)

<center>
![](pictures/animal_welfare.jpeg){width="50%"}
  \
<sup><sub> [Image Source](https://ahrecs.com/wp-content/uploads/2022/06/Wordcloud_1769782790.jpeg) </sub></sup>
</center>


<!-- Slide 17 -->

## Implications of the Live Model

- Non-invasive way of estimating abalone age, with only small penalty in accuracy
- More socially acceptable and is more versatile for monitoring abalone populations
- However, additional effort is required to properly return the abalone to their habitats

<center>
![](pictures/abalone_colony.jpg){width="55%"}
  \
<sup><sub> [Image Source](https://www.biologicaldiversity.org/species/invertebrates/black_abalone/natural_history.html) </sub></sup>
</center>

<!-- Slide 18 -->

## Comparison of Models

- Since the live model offers similar accuracy while preserving the abalone, it is our preferred model
- However, care should be taken when collecting data for this model to ensure that the abalone aren’t harmed
    - Abalone are haemophiliacs so they can't clot blood
  \
  \

::: columns
::: {.column width="50%"}

_Live Model (scaled)_
```{r, message=FALSE, warning=FALSE}
cv_scaled = train(
  Rings ~ ., 
  data = data_scaled_live,
  method = "lm",
  trControl = trainControl(
    method = "cv", number = 10,
    verboseIter = FALSE
  )
)
round(cv_scaled$results[c("Rsquared", "RMSE", "MAE")], 3) |> knitr::kable()
```

:::
::: {.column width="50%"}

_Original Model (scaled)_
```{r, message=FALSE, warning=FALSE}
cv_live_scaled = train(
  Rings ~ ., 
  data = data_scaled,
  method = "lm",
  trControl = trainControl(
    method = "cv", number = 10,
    verboseIter = FALSE
  )
)
round(cv_live_scaled$results[c("Rsquared", "RMSE", "MAE")], 3) |> knitr::kable()
```

:::
:::

<!-- Slide 19 -->

## Limitations

- Interpretability of the model if relatively low due to scaling
- Model is sensitive to rounding error due to low coefficients
- May not apply to some species of abalone
- AIC minimisation also has some limitations (Hurvich & Tsai, 1989)

<center>
![](pictures/abalone_map.gif){width="60%"}
  \
<sup><sub> [Image Source](https://www.vetigastropoda.com/ABMAP/text/worldmap.html) </sub></sup>
</center>

<sup><sub> Hurvich, C. M., & Tsai, C. (1989). Regression and time series model selection in small samples. Biometrika, 76(2), 297–307. https://doi.org/10.1093/biomet/76.2.297 </sub></sup>

<!-- Slide 20 -->

## Future Directions and Conclusion

- Overall, we found that the live, non-invasive model was preferred
- In the future, we could the model on other species of abalone or abalone from other places in the world
- We will also source stakeholder investment to help improve our model

<center>
![](pictures/measuring_abalone.jpg){width="40%"} 
  \
<sup><sub> [Image Source](https://www.scubadoctor.com.au/assets/images/measuring-abalone.jpg) </sub></sup>
</center>